import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';
import { startOfDay, endOfDay, parseISO, format, eachDayOfInterval } from 'date-fns';

interface TrendDataPoint {
  date: string;
  download: number;
  upload: number;
  ping: number;
}

interface OfficeData {
  office: {
    id: string;
    unitOffice: string;
    subUnitOffice?: string;
    location: string;
  };
  data: TrendDataPoint[];
  latestValues: {
    download: number;
    upload: number;
    ping: number;
    date: string;
  };
}

// Type for the final API response expected by frontend
interface TrendResponse {
  date: string;
  office: string;
  avgDownload: number;
  avgUpload: number;
  avgPing: number;
}

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    if ((session.user as any)?.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
    }    const { searchParams } = new URL(request.url);
    const startDate = searchParams.get('startDate');
    const endDate = searchParams.get('endDate');
    const unit = searchParams.get('unit');
    const subunit = searchParams.get('subunit');
    const isp = searchParams.get('isp');
    const section = searchParams.get('section');
    const timeOfDay = searchParams.get('timeOfDay');

    if (!startDate || !endDate) {
      return NextResponse.json(
        { error: 'Start date and end date are required' },
        { status: 400 }
      );
    }

    const start = startOfDay(parseISO(startDate));
    const end = endOfDay(parseISO(endDate));    // Build where clause for office filtering
    const whereClause: any = {};
    if (unit) {
      whereClause.unitOffice = unit;
    }
    if (subunit) {
      whereClause.subUnitOffice = subunit;
    }
    if (section) {
      whereClause.section = section;
    }

    // Build speed test where clause
    const speedTestWhere: any = {
      timestamp: {
        gte: start,
        lte: end,
      },
    };    // Add ISP filter - handle partial matches for ISPs with sections like "PLDT (IT)"
    if (isp) {
      speedTestWhere.isp = {
        contains: isp,
        mode: 'insensitive'
      };
      console.log('Filtering by ISP (partial match):', isp);
    }

    // Note: Time of day filtering is handled in the data processing logic below
    console.log('Speed test where clause:', speedTestWhere);
      // Fetch offices with their speed tests
    const offices = await prisma.office.findMany({
      where: whereClause,
      include: {
        speedTests: {
          where: speedTestWhere,
          orderBy: {
            timestamp: 'asc',
          },
        },
      },
    });    console.log('Fetched offices count:', offices.length);
    console.log('Total speed tests found:', offices.reduce((total, office) => total + office.speedTests.length, 0));
    
    // Log first few speed tests for debugging
    if (offices.length > 0 && offices[0].speedTests.length > 0) {
      console.log('Sample speed test:', {
        isp: offices[0].speedTests[0].isp,
        timestamp: offices[0].speedTests[0].timestamp,
        download: offices[0].speedTests[0].download
      });
    }

    // If filtering by ISP, let's check what ISPs are actually in the speed tests
    if (isp) {
      const allSpeedTests = offices.flatMap(office => office.speedTests);
      const uniqueISPs = [...new Set(allSpeedTests.map(test => test.isp))];
      console.log('All unique ISPs in speed tests:', uniqueISPs);
      console.log('Requested ISP filter:', isp);
      console.log('ISP filter match found:', uniqueISPs.includes(isp));
    }const processedOffices: OfficeData[] = offices.map((office: any) => {
      // Get all dates in the range
      const dateRange = eachDayOfInterval({ start, end });
      
      // Group speed tests by date
      const testsByDate = new Map<string, any[]>();
      
      // Filter speed tests by time of day if specified
      let filteredTests = office.speedTests;
      if (timeOfDay) {
        let hourStart = 0, hourEnd = 23;
        switch (timeOfDay) {
          case 'morning':
            hourStart = 6; hourEnd = 11; // 6:00 AM - 11:59 AM
            break;
          case 'noon':
            hourStart = 12; hourEnd = 12; // 12:00 PM - 12:59 PM
            break;
          case 'afternoon':
            hourStart = 13; hourEnd = 18; // 1:00 PM - 6:00 PM
            break;
        }
        
        filteredTests = office.speedTests.filter((test: any) => {
          const testHour = new Date(test.timestamp).getHours();
          return testHour >= hourStart && testHour <= hourEnd;
        });
      }
      
      filteredTests.forEach((test: any) => {
        const testDate = format(test.timestamp, 'yyyy-MM-dd');
        if (!testsByDate.has(testDate)) {
          testsByDate.set(testDate, []);
        }
        testsByDate.get(testDate)!.push(test);
      });

      // Create trend data points for each date
      const trendData: TrendDataPoint[] = dateRange.map(date => {
        const dateStr = format(date, 'yyyy-MM-dd');
        const dayTests = testsByDate.get(dateStr) || [];
        
        if (dayTests.length === 0) {
          return {
            date: dateStr,
            download: 0,
            upload: 0,
            ping: 0,
          };
        }

        // Calculate averages for the day
        const totals = dayTests.reduce(
          (acc: any, test: any) => ({
            download: acc.download + test.download,
            upload: acc.upload + test.upload,
            ping: acc.ping + test.ping,
          }),
          { download: 0, upload: 0, ping: 0 }
        );

        return {
          date: dateStr,
          download: totals.download / dayTests.length,
          upload: totals.upload / dayTests.length,
          ping: totals.ping / dayTests.length,
        };
      });

      // Filter out days with no data
      const validData = trendData.filter(point => 
        point.download > 0 || point.upload > 0 || point.ping > 0
      );

      // Get latest values
      const latestPoint = validData[validData.length - 1] || {
        date: format(new Date(), 'yyyy-MM-dd'),
        download: 0,
        upload: 0,
        ping: 0,
      };

      return {
        office: {
          id: office.id,
          unitOffice: office.unitOffice,
          subUnitOffice: office.subUnitOffice || undefined,
          location: office.location,
        },
        data: validData,
        latestValues: {
          download: latestPoint.download,
          upload: latestPoint.upload,
          ping: latestPoint.ping,
          date: latestPoint.date,
        },
      };
    });    // Filter out offices with no data
    const officesWithData = processedOffices.filter(office => office.data.length > 0);

    // Return individual data points with office details for more granular tooltips
    const detailedTrendData: any[] = [];
    officesWithData.forEach(office => {
      office.data.forEach((dataPoint: TrendDataPoint) => {
        if (dataPoint.download > 0 || dataPoint.upload > 0 || dataPoint.ping > 0) {
          detailedTrendData.push({
            date: dataPoint.date,
            office: `${office.office.unitOffice}${office.office.subUnitOffice ? ' > ' + office.office.subUnitOffice : ''}`,
            unit: office.office.unitOffice,
            subunit: office.office.subUnitOffice || undefined,
            section: (office.office as any).section || undefined,
            isp: undefined, // TODO: Will be populated from speed test data if available
            timeOfDay: undefined, // Will be populated based on filtering
            avgDownload: dataPoint.download,
            avgUpload: dataPoint.upload,
            avgPing: dataPoint.ping,
            testCount: 1
          });
        }
      });
    });

    // If we have no detailed data, fall back to aggregated approach
    if (detailedTrendData.length === 0) {
      // Aggregate all offices by date as fallback
      const aggregatedData = new Map<string, { download: number[], upload: number[], ping: number[] }>();
      officesWithData.forEach(office => {
        office.data.forEach((dataPoint: TrendDataPoint) => {
          if (!aggregatedData.has(dataPoint.date)) {
            aggregatedData.set(dataPoint.date, { download: [], upload: [], ping: [] });
          }
          const dayData = aggregatedData.get(dataPoint.date)!;
          if (dataPoint.download > 0) dayData.download.push(dataPoint.download);
          if (dataPoint.upload > 0) dayData.upload.push(dataPoint.upload);
          if (dataPoint.ping > 0) dayData.ping.push(dataPoint.ping);
        });
      });

      // Convert to the format expected by the frontend
      const fallbackData = Array.from(aggregatedData.entries()).map(([date, values]) => ({
        date,
        office: `${officesWithData.length} offices`, // Summary label
        avgDownload: values.download.length > 0 ? values.download.reduce((a, b) => a + b, 0) / values.download.length : 0,
        avgUpload: values.upload.length > 0 ? values.upload.reduce((a, b) => a + b, 0) / values.upload.length : 0,
        avgPing: values.ping.length > 0 ? values.ping.reduce((a, b) => a + b, 0) / values.ping.length : 0,
      })).sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());

      return NextResponse.json(fallbackData);
    }

    // Sort detailed data by date
    detailedTrendData.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());

    return NextResponse.json(detailedTrendData);
  } catch (error) {
    console.error('Error fetching trend data:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
